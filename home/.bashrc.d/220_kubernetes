alias k=kubectl
complete -o default -F __start_kubectl k

set_kube_current_ns()
{
  kubectl config set-context $(kubectl config current-context) --namespace="${1:-sudermanjr}"
}
alias kns=kubens
alias kgetns="kubectl config get-contexts | grep $(kubectl config current-context) | awk '{print \$5}' | tr -d '\n'"

alias kdash="kubectl get po -n=kube-system | grep dashboard | awk '{print \$1}' | xargs -I %  kubectl port-forward % 8001 -n=kube-system"
alias kwatch="watch kubectl get ds,deploy,hpa,po,svc,ing,cm"
alias kwatchistio="watch kubectl get ds,deploy,po,svc,ing,cm,pvc,secret,cronjob,routerule"
alias kgetall="kubectl api-resources --verbs=list --namespaced -o name | xargs -L 1 -I {} kubectl get {} --show-kind --ignore-not-found"

kc() {
  kubectl -n "${namespace}" $@
}

generate_kubeconfig_from_sa() {
  namespace="$1"
  serviceaccount="$2"

  sa_secret_name=$(kc get serviceaccount "${serviceaccount}" -o 'jsonpath={.secrets[0].name}')

  context_name="$(kubectl config current-context)"
  kubeconfig_old="${KUBECONFIG}"
  cluster_name="$(kubectl config view -o "jsonpath={.contexts[?(@.name==\"${context_name}\")].context.cluster}")"
  server_name="$(kubectl config view -o "jsonpath={.clusters[?(@.name==\"${cluster_name}\")].cluster.server}")"
  cacert="$(kc get secret "${sa_secret_name}" -o "jsonpath={.data.ca\.crt}" | base64 --decode)"
  token="$(kc get secret "${sa_secret_name}" -o "jsonpath={.data.token}" | base64 --decode)"

  export KUBECONFIG="$(mktemp)"
  kubectl config set-credentials "${serviceaccount}" --token="${token}" >/dev/null
  ca_crt="$(mktemp)"; echo "${cacert}" > ${ca_crt}
  kubectl config set-cluster "${cluster_name}" --server="${server_name}" --certificate-authority="$ca_crt" --embed-certs >/dev/null
  kubectl config set-context "${cluster_name}" --cluster="${cluster_name}" --user="${serviceaccount}" >/dev/null
  kubectl config use-context "${cluster_name}" >/dev/null

  KUBECONFIG_DATA=$(cat "${KUBECONFIG}")
  rm ${KUBECONFIG}
  echo "${KUBECONFIG_DATA}"
  export KUBECONFIG="${kubeconfig_old}"
}

## Krew
export PATH="${KREW_ROOT:-$HOME/.krew}/bin:$PATH"

# Kubesec
kubesec ()
{
    local FILE="${1:-}";
    [[ ! -f "${FILE}" ]] && {
        echo "kubesec: ${FILE}: No such file" >&2;
        return 1
    };
    curl --silent \
      --compressed \
      --connect-timeout 5 \
      -F file=@"${FILE}" \
      https://kubesec.io/
}

kdebug ()
{
  kubectl create ns sudermanjr-debug
  kubectl -n sudermanjr-debug apply -f ~/repos/sudermanjr/utilities/utility-deploy.yaml
}

helmversion ()
{
  export TILLER_NAMESPACE=$(kubectl get deploy --all-namespaces | grep tiller | awk {'print $1}')
  export TILLER_IMAGE=$(kubectl get deploy tiller-deploy -oyaml -n "$TILLER_NAMESPACE" | yq r - spec.template.spec.containers[0].image)
  export TILLER_VERSION=$(cut -d ":" -f 2 <<< "$TILLER_IMAGE" | sed 's/v//g')
  brew switch kubernetes-helm $TILLER_VERSION
}

helminit ()
{
  kubectl create ns helm-system || true
  export TILLER_NAMESPACE=helm-system
  kubectl create clusterrolebinding tiller --clusterrole cluster-admin --serviceaccount="${TILLER_NAMESPACE:-kube-system}":tiller --serviceaccount=kube-system:tiller -o yaml --dry-run | kubectl -n "${TILLER_NAMESPACE:-kube-system}" apply -f -
  kubectl -n "${TILLER_NAMESPACE:-kube-system}" create sa tiller --dry-run -o yaml --save-config | kubectl apply -f -
  helm init --upgrade --service-account tiller
}

export KUBECONFIG=~/.kube/config
